Replicating the Amstrad CPC 464 Game West Bank in Python: An Architectural Blueprint for High-Fidelity EmulationThe recreation of a vintage 8-bit computer game such as West Bank (published by Dinamic Software, 1985, and based on the arcade game Bank Panic) requires a deep understanding of the source machine's architectural constraints. Achieving authentic fidelity in the Python/Pygame environment means simulating the timing, visual limitations, and audio synthesis capabilities inherent to the Amstrad CPC 464.1 This report details the necessary foundation, mechanical logic, and implementation strategies required for an accurate retro recreation.I. Architectural Foundation: Understanding the Amstrad CPC 464I.A. Historical Context and Fidelity ImperativesWest Bank is a reaction-based shoot-'em-up that demands highly precise timing from the player. The game's feel and difficulty are fundamentally dictated by the limitations of the Amstrad CPC 464 hardware.2The CPC 464 utilized a Zilog Z80A CPU running at 4 MHz, coupled with 64KB of memory, expandable up to 576KB.3 These specifications defined a strict performance ceiling. Unlike modern systems with highly variable frame rates, 8-bit systems, particularly in Europe, adhered to a fixed refresh rate of 50 Hz. To capture the authentic aesthetic, one must acknowledge the original programming compromises. For instance, an early developer of a similar West Bank concept noted that, to save memory and be small enough for magazine publication, "small graphics objects" were created and then zoomed, resulting in a "very crude and bulky look".4 Therefore, maximizing fidelity dictates that graphical interpolation techniques commonly found in modern engines must be abandoned in favor of rigid pixel integrity and fixed timing.I.B. Replicating the Z80 Clock Cycle and Game Loop TimingThe core challenge in emulating Z80 systems is synchronizing the game logic to the hardware clock rate. The Amstrad CPC utilized a Motorola 6845 CRTC (Cathode Ray Tube Controller) chip to manage display timing.3 This chip generated a crucial interrupt known as the Vertical Blanking Interrupt (VBI), typically at the display refresh rate (50 Hz for PAL systems like the UK/European CPC).3The game loop itself was invariably synchronized to this VBI. The design of West Bank confirms this: the original developer mentioned the doors opening and closing were "controlled by an interrupt".4 This interrupt-driven timing ensures that when a hostile character requires exactly 10 frames (or VBI ticks) to draw their gun, that timing window is precise and unalterable. This relationship between the fixed 50 Hz hardware refresh rate and the game logic state transitions is paramount to the player experience. If the simulation uses a variable frame rate, the perceived difficulty and reaction windows will be inconsistent, compromising the game’s essence.To simulate this fixed determinism in Python, the game must leverage Pygame's built-in time management tools. The pygame.time.Clock.tick() function must be employed to enforce a stable frame rate, typically $50$ FPS, which mimics the PAL VBI loop.5 Movement and dynamic logic should be updated using a delta time ($\\Delta t$) calculated from this fixed clock, ensuring that game object state transitions—such as the crucial time it takes for a bandit to draw their weapon—are defined in discrete, reproducible VBI ticks, thus accurately reflecting the original Z80 timing.6I.C. Graphics Mode Analysis and Palette MappingThe Amstrad CPC 464 offered multiple graphics modes, trading resolution for color depth, dictated by the CRTC and the machine's memory layout.7 Understanding these modes is essential for establishing the aesthetic target for the Pygame surface.The primary modes available were:Mode 0: 160 x 200 pixels with 16 colors.Mode 1: 320 x 200 pixels with 4 colors.Mode 2: 640 x 200 pixels with 2 colors.3Mode 1 (320x200 with 4 colors) was a common choice for many commercial ports, offering a balance between detail and memory usage.7 However, Mode 0 (160x200 with 16 colors) provides the richest color palette available on the base machine. Given the requirement to capture the "crude and bulky look" 4, a low-resolution mode is preferred.The technical blueprint necessitates the creation of a Virtual Screen Surface in Pygame matching the chosen CPC resolution (e.g., $320 \\times 200$ pixels). All game rendering is performed onto this small surface. To display this on a modern high-resolution monitor while preserving the characteristic pixelation, the game must employ Integer Scaling (nearest-neighbor sampling).10 Functions like pygame.transform.scale2x or pygame.transform.smoothscale\_by with an integer factor should be used to scale the virtual screen to the user's display without introducing artifacting or smoothing.11CPC Graphics Modes and Recommended Pygame Scaling StrategyCPC ModeResolution (H x V)Color Depth (Inks)Pygame Virtual Surface SizeScaling Method RecommendedAesthetic GoalMode 0$160 \\times 200$16$160 \\times 200$Integer Scaling (e.g., 4x)Maximizing color palette while preserving large pixel blocks.Mode 1$320 \\times 200$4$320 \\times 200$Integer Scaling (e.g., 2x)Ideal resolution/color balance for visual definition in a port.Mode 2$640 \\times 200$2$640 \\times 200$N/ATypically reserved for low-color text displays.II. Mechanistic Deconstruction: Core Gameplay Logic of West BankThe fundamental mechanics of West Bank revolve around rapid pattern recognition, precise timing, and decision-making within a tight, multi-lane structure.II.A. The Bank Environment and Scrolling MechanicsThe game environment consists of a bank counter facade with three defined doorways (Left, Middle, Right).2 The player operates a gun, which is positioned in the foreground. The original CPC controls allowed horizontal movement (using keys O and P) to shift the camera/gun sight across a wider background, implying a horizontally scrollable playfield.2To simulate this, the Python blueprint must manage a BankManager class that maintains a continuous CameraXOffset variable. The player’s lateral input shifts this offset, causing the background environment (the bank wall, counter) to pan underneath. Crucially, the three interactive doorways must maintain their defined positions relative to the camera view, ensuring the player always knows which door corresponds to the shoot input keys (1, 2, or 3).2Each doorway requires a Door class managing a state machine: CLOSED, OPENING, OPEN, and CLOSING. These state transitions must be driven by the fixed $50$ Hz game loop timing established in Section I.B, creating reliable animation speeds that match the original hardware timing derived from the CRTC interrupt.4 The Door object must also contain a reference to the Character object currently revealed behind it.II.B. Defining Character Archetypes and Reaction LogicThe primary gameplay mechanism relies on distinguishing harmless customers from dangerous bandits and gunslingers. Failure to react appropriately—either shooting an innocent customer or failing to shoot a bandit in time—results in the loss of one of the player's three lives.2The character logic must be defined by distinct, timed states. For hostile characters (Bandit and Gunslinger), the critical rule is: "you are only allowed to shoot when the enemy draws his pistol".2 This dictates a required sequence of states:STATE.WAITING: The hostile character is revealed, potentially holding a non-threatening object (like a money sack) or their hand near their holster. Shooting during this state is an error (premature shot), resulting in a penalty.STATE.DRAWING: The character transitions to drawing their weapon. This moment defines the incredibly narrow, critical timing window for the player to shoot. In later levels ("following days"), this window shrinks dramatically (potentially to only $2$ to $5$ VBI ticks, or $40$–$100$ ms).2STATE.FIRING: If the player fails to hit the target during the DRAWING state, the bandit automatically enters the FIRING state, resulting in an immediate player life loss.2The structure of the game's challenge suggests that character appearances are not random but scheduled. Disassembly resources for related Z80 systems confirm that these games rely on structured data tables and buffers for graphics and game status.13 This implies a need for a Python CharacterSequenceGenerator that dictates the specific type of character and their timing sequence based on the current "Day" level. As the difficulty progresses, this generator must increase the frequency of high-difficulty characters (Gunslingers) and dramatically reduce the VBI tick count allocated to the crucial STATE.DRAWING window.II.C. The Three-Hat Man Dilemma: Modeling Uncertainty and LogicA unique element of West Bank is the appearance of "The small man with the many hats".2 This character, often associated with logic puzzles, may carry either money or a bomb.14 The player is required to deduce whether the character is carrying a bomb, which must be shot immediately, or money, which must be allowed to deposit.2This mechanic serves as a quick visual logic gate. The implementation requires the ThreeHatCharacter class to have a binary internal state (IS\\\_BOMB = True/False). If the state is True, the character's visual representation must quickly display the bomb, triggering the necessary hostile shot response from the player. If the state is False, the visual cue must be a non-threatening object (money bag), and a shot against this character is penalized as shooting an innocent customer.2 The entire animation cycle for this character is extremely brief, forcing the player to make an immediate, high-stakes decision based solely on the visual cue. The challenge mirrors advanced hat-guessing induction problems where a quick, shared understanding of conditions is necessary for success.14III. Python/Pygame Implementation BlueprintThe recreation must be built upon the architectural constraints established in Section I, utilizing Pygame for rapid 2D development and hardware interface management.17III.A. Setting Up the Pygame Environment and Game LoopThe Pygame environment must be initialized with specific constraints to support retro fidelity. Importantly, the Pygame mixer must be configured before initialization to support the low-level audio requirements (Section IV).18The main game loop is the heart of the recreation. It must adhere to the fixed-rate timing derived from the CPC's VBI:Pythonimport pygame



\# Initialize mixer for 8-bit sound (44100 Hz, signed 8-bit PCM)

pygame.mixer.pre\_init(44100, size=-8, channels=3) 

pygame.init()



\# Define the virtual screen size (e.g., Mode 1)

VIRTUAL\_WIDTH, VIRTUAL\_HEIGHT = 320, 200

VIRTUAL\_SCREEN = pygame.Surface((VIRTUAL\_WIDTH, VIRTUAL\_HEIGHT))



\# Define the actual display size (4x integer scaling recommended)

SCALE\_FACTOR = 4

SCREEN\_WIDTH, SCREEN\_HEIGHT = VIRTUAL\_WIDTH \* SCALE\_FACTOR, VIRTUAL\_HEIGHT \* SCALE\_FACTOR

SCREEN = pygame.display.set\_mode((SCREEN\_WIDTH, SCREEN\_HEIGHT))



CLOCK = pygame.time.Clock()

FPS = 50 # PAL VBI frequency



running = True

while running:

&nbsp;   dt = CLOCK.tick(FPS) / 1000.0  # Calculate Delta Time in seconds

&nbsp;   

&nbsp;   # 1. Handle Events (Input: Shoot 1, 2, 3, Scroll O/P)

&nbsp;   # 2. Update Game Logic (Character state machines, door timings using dt)

&nbsp;   # 3. Draw (Render all elements to VIRTUAL\_SCREEN)

&nbsp;   

&nbsp;   # 4. Scale and Display

&nbsp;   scaled\_surface = pygame.transform.scale(VIRTUAL\_SCREEN, (SCREEN\_WIDTH, SCREEN\_HEIGHT))

&nbsp;   SCREEN.blit(scaled\_surface, (0, 0))

&nbsp;   pygame.display.flip()

The core game logic must be implemented using object-oriented principles, with all dynamic elements (doors, characters, bullets) inheriting from pygame.sprite.Sprite for efficient management and optimized collision checks.19III.B. Graphics and Asset ReplicationThe aesthetic fidelity depends on creating assets that adhere strictly to the chosen CPC color palette (e.g., 4 colors in Mode 1) and resolution. Sprites should be designed in small, chunky pixel art formats, often in multiples of 8 pixels, reflecting the memory conservation techniques of the original developers.4Sprite handling involves loading the low-resolution images and using the blit() function to draw them onto the VIRTUAL\_SCREEN. The horizontal scrolling is implemented by offsetting the drawing position of the background and door elements based on the dynamically updated CameraXOffset variable, linked to the player's scroll input.2 The use of integer scaling ensures that the final display maintains the blocky, retro look, resisting the tendency of modern rendering pipelines to smooth edges.11III.C. Precision Input and Collision DetectionAccurate input handling and collision detection must be integrated with the strict timing mechanism.Input Mapping: The original controls (1, 2, 3 for shooting, O/P for scrolling) should be mapped to accessible modern keyboard keys or joystick inputs.2Collision Detection: Pygame's pygame.sprite.spritecollide() function can check for the collision between the player's bullet sprite and the character sprite visible in the doorway.19Timing Verification: The crucial check happens immediately after collision: the system must verify the state of the targeted Character object at the exact moment of the shot. If the character's internal state flag is STATE.DRAWING, the shot is successful. If the state is STATE.WAITING (shot too early/innocent customer) or Character.IS\_BOMB == False (Three-Hat Man with money), or if the shot occurs after the transition to STATE.FIRING (shot too late), a penalty (life loss) must be applied.2 This state verification within the fixed 50 Hz cycle ensures fidelity to the required millisecond-precision reaction time.IV. Audio Fidelity: AY-3-8912 Synthesis in PygameAuthentic retro sound is one of the most complex aspects of emulation. The Amstrad CPC 464 used the General Instrument AY-3-8912, a 3-voice Programmable Sound Generator (PSG) chip.21 This chip produces sound using three independent channels capable of square waves, combined with a dedicated noise channel, all modulated by a shared volume envelope generator.22IV.A. AY-3-8912 Architecture and TheoryThe characteristic sounds of the CPC—including music and effects—result from rapid manipulation of the AY chip's 16 internal registers.21 Simply playing sampled audio files does not capture the raw, digital nature of the original sounds, which are essentially raw sequences of register writes played back by the Z80.To simulate this digitally constrained output, a procedural audio synthesis approach is mandatory. This involves generating the raw waveform data (Pulse-Code Modulation or PCM) in Python based on simulated register settings, and then feeding this data directly to the Pygame mixer.18IV.B. Low-Level Sound Generation via Pygame MixerThe critical step for 8-bit sound emulation is the Pygame mixer initialization. The mixer must be configured to utilize signed 8-bit PCM (size=-8), matching the low bit depth typical of classic sound chips.18 A high sample rate (e.g., $44100$ Hz) is used for clarity, but the bit depth remains constrained to 8-bit, providing the raw, clipped digital quality necessary.An AYEmulator class must be implemented in Python to model the three tone channels and one noise channel.21 This class receives virtual commands mimicking Z80 register writes (e.g., setting Tone Period registers R0-R5, Volume registers R8-R10, and Envelope Period registers R11-R12).22 It then calculates the required raw audio buffer (an array of signed 8-bit samples, typically a square wave modulated by the noise channel), which is then passed to a pygame.mixer.Sound object for playback.18IV.C. Replicating Game-Specific Sound EventsThe characteristic sound events in West Bank are directly tied to rapid manipulation of the AY-3-8912 registers:Sound EventCore AY Channels UsedPygame Mixer Configuration DetailWave Generation FocusGunshot ("Schput")Tone (A/B) + NoiseUtilizes $44100$ Hz, signed 8-bit PCM output 18Very short, high-frequency square wave burst (Tone Period R0/R1 set low), combined immediately with a brief activation of the Noise channel.Explosion/BombNoise Channel (C)Raw buffer creation using array and pygame.mixer.Sound 23Maximum volume noise. Envelope registers R11/R12 dictate a short, rapid decay (explosion characteristic).22Door Opening/ClosingTone (A/B/C)Output is highly procedural and duration-dependent on the VBI loop.Utilizes very low-frequency tone periods (R0/R1 set high) to simulate a mechanical motor or interrupt signal.4The gunshot effect, often described as a "schput" 24, should be varied slightly in pitch depending on which of the three doors is shot, reflecting subtle channel differences seen in other Z80 ports.24 Utilizing the procedural synthesis approach is the only way to ensure these rapid, low-bitrate effects sound authentically digital and constrained by the AY hardware.V. Advanced Replication Techniques and ExtensibilityV.A. Leveraging Z80 Disassembly for Logic IntegrityWhile the exact Z80 source code for the CPC version of West Bank (Dinamic Software) is challenging to locate, Z80 assembly disassembly projects exist for similar versions (e.g., the ZX Spectrum version, which shares the Z80 CPU architecture).13Analyzing the structural components of such disassemblies provides a crucial roadmap for structuring the Python game state variables. Information categories found in these analyses, such as "Graphics," "Data tables and buffers," and the "Game status buffer," provide necessary context.13 The analysis establishes that variables governing character position, animation state, and game timing are meticulously controlled by the Z80 program counter and memory addressing.25This means the Python implementation should utilize variable names and state machine structures that mirror this original 8-bit logic, even if the implementation is high-level. By correlating the high-level Python logic (e.g., Door.STATE\_DRAWING) with the conceptual state variables present in the Z80 machine’s memory map, the recreation maintains logical integrity with its heritage.26V.B. Difficulty Scaling and High Score PersistenceThe primary method of increasing difficulty in West Bank is by manipulating time. As noted, the game escalates on "following days".2 The game difficulty is defined by the following algorithmic manipulation:Increased Frequency of Hostiles: The CharacterSequenceGenerator must increase the probability weight for hostile characters (Bandits and Gunslingers) appearing in the next door cycle.Decreased Reaction Window: The most profound difficulty increase is achieved by reducing the number of VBI ticks allocated to the STATE.DRAWING window, demanding progressively faster reaction times from the player, moving from perhaps 10 ticks down to 2 or 3 ticks in later days.Complex Character Introduction: Ensuring the volatile Three-Hat Man appears more frequently at higher days to force complex, rapid deductive decisions.2High score persistence is a standard requirement for retro games. Scores should be tracked internally and saved locally using Python’s file I/O capabilities. When displaying these scores, the rendering should employ a retro-style text implementation, mirroring the CPC's limited 40x25 or 80x25 text modes, potentially utilizing customized fonts to maintain visual consistency.9V.C. Extensibility and Future Retro EnhancementsTo ensure the framework is robust and extensible for true enthusiasts, several advanced enhancements are recommended:Customizable CPC Palette: The Amstrad CPC could display 27 distinct colors.9 The implementation should include a simple configuration option allowing the user to map the four colors used in Mode 1 (or 16 colors in Mode 0) to different primary CPC color indices, simulating various monitor calibrations used across different hardware setups.Optimized Rendering Pipeline: While Pygame handles transformations adequately, repeatedly scaling the virtual screen in the main game loop can introduce performance bottlenecks. Advanced techniques could involve pre-rendering or caching the final scaled sprite output, thereby ensuring that the fixed $50$ FPS target is maintained rigorously, regardless of the host machine’s load.Path to Cycle-Accuracy: For the highest level of emulation fidelity, the Python game loop can be restructured to communicate with a low-level, high-performance Z80 emulation core (perhaps implemented in C or Rust) via system libraries. This core would handle the character state transitions and timing on a clock-cycle basis, moving beyond simple VBI locking to achieve true cycle-accurate timing simulation, which is the definitive standard for preserving vintage game difficulty.VI. ConclusionsThe ambitious project to recreate the Amstrad CPC 464 game West Bank in Python using Pygame is highly feasible, provided the implementation rigidly respects the constraints of the original 8-bit architecture.The core necessity is disciplined simulation of the Zilog Z80A processing environment. This requires locking the game loop to the fixed $50$ Hz Vertical Blanking Interrupt rate using Pygame’s clock controls.5 Graphical fidelity is achieved by rendering to a low-resolution surface (e.g., $320 \\times 200$) and scaling it up via integer methods, preserving the "crude and bulky" pixel aesthetic inherent to the original memory constraints.4Mechanically, the game relies on precise, time-gated character state machines (WAITING $\\rightarrow$ DRAWING $\\rightarrow$ FIRING) where the critical reaction window is defined by a diminishing number of VBI ticks as the difficulty increases.2 The complexity introduced by the unique Three-Hat Man character further tests the player’s ability to execute rapid, logic-based decisions.14Finally, audio authenticity mandates the synthesis of sound via procedural generation, simulating the General Instrument AY-3-8912’s square wave and noise channels. This requires initializing the Pygame mixer for signed 8-bit PCM output, a necessary step to capture the raw, digital quality of the chip’s sound effects.18 By adhering to these foundational technical requirements, the Python recreation can deliver an experience functionally and aesthetically indistinguishable from the cherished Amstrad original.

